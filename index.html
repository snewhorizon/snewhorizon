<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Conway's Game of Life — Web App</title>
  <style>
    :root{--bg:#0f1724;--panel:#0b1220;--accent:#06b6d4;--muted:#94a3b8;}
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,'Noto Sans JP',sans-serif;background:var(--bg);color:#e6eef6}
    .app{display:grid;grid-template-columns:1fr 320px;gap:18px;max-width:1200px;margin:24px auto;padding:18px}
    .board-card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:12px;box-shadow:0 6px 24px rgba(2,6,23,0.6)}
    canvas{display:block;border-radius:8px;width:100%;height:calc(100vh - 120px);background:linear-gradient(180deg,#071025 0%, #021019 100%)}
    .controls{background:var(--panel);padding:12px;border-radius:12px;height:100%}
    .row{display:flex;gap:8px;align-items:center;margin:8px 0}
    button{background:transparent;border:1px solid rgba(255,255,255,0.06);color:inherit;padding:8px 10px;border-radius:8px;cursor:pointer}
    button.primary{background:var(--accent);border-color:transparent;color:#042022}
    input[type=range]{width:100%}
    label{font-size:13px;color:var(--muted)}
    select,input[type=number]{width:100%;padding:6px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
    .small{font-size:13px}
    .footer{font-size:13px;color:var(--muted);margin-top:8px}
    .preset-list{display:flex;flex-wrap:wrap;gap:8px}
    .preset-list button{padding:6px 8px;font-size:13px}
    @media (max-width:980px){.app{grid-template-columns:1fr; padding:12px}.controls{order:2}}
  </style>
</head>
<body>
  <div class="app">
    <div class="board-card">
      <canvas id="lifeCanvas"></canvas>
      <div class="footer">クリックでセルを切り替え。ドラッグで塗れる。ダブルクリックで停止/再生切替。</div>
    </div>

    <aside class="controls">
      <div class="row">
        <button id="startBtn" class="primary">再生</button>
        <button id="stepBtn">ステップ</button>
        <button id="clearBtn">クリア</button>
        <button id="randomBtn">ランダム</button>
      </div>

      <div class="row">
        <div style="flex:1">
          <label>スピード（ms / 世代）</label>
          <input id="speedRange" type="range" min="20" max="1000" value="150">
        </div>
      </div>

      <div class="row">
        <div style="flex:1">
          <label>セルサイズ（px）</label>
          <input id="cellSize" type="number" min="4" max="60" value="12">
        </div>
      </div>

      <div class="row">
        <div style="flex:1">
          <label>ラップ（境界をトーラスにする）</label>
          <select id="wrapSelect">
            <option value="true">有効</option>
            <option value="false">無効</option>
          </select>
        </div>
      </div>

      <div class="row">
        <div style="flex:1">
          <label>グリッド表示</label>
          <select id="gridSelect">
            <option value="true">表示</option>
            <option value="false">非表示</option>
          </select>
        </div>
      </div>

      <div style="margin-top:8px">
        <label>プリセット</label>
        <div class="preset-list" id="presets"></div>
      </div>

      <div style="margin-top:10px">
        <label>色</label>
        <div class="row">
          <input id="aliveColor" type="color" value="#06b6d4">
          <input id="deadColor" type="color" value="#021019">
        </div>
      </div>

      <div style="margin-top:10px" class="small">行動: 盤面上でクリックしてセルを変更。再生中でもダブルクリックで再生/停止。ドラッグで塗りつぶし可能。</div>

      <div style="margin-top:10px" class="small">作成: Game of Life — single-file HTML. 必要ならパターン追加や保存機能を追加できます。</div>
    </aside>
  </div>

  <script>
    // Game of Life — clean, single-file implementation
    const canvas = document.getElementById('lifeCanvas');
    const ctx = canvas.getContext('2d', {alpha:false});

    // Controls
    const startBtn = document.getElementById('startBtn');
    const stepBtn = document.getElementById('stepBtn');
    const clearBtn = document.getElementById('clearBtn');
    const randomBtn = document.getElementById('randomBtn');
    const speedRange = document.getElementById('speedRange');
    const cellSizeInput = document.getElementById('cellSize');
    const wrapSelect = document.getElementById('wrapSelect');
    const gridSelect = document.getElementById('gridSelect');
    const presetsDiv = document.getElementById('presets');
    const aliveColorInput = document.getElementById('aliveColor');
    const deadColorInput = document.getElementById('deadColor');

    let cellSize = Number(cellSizeInput.value);
    let cols = 0, rows = 0;
    let grid = [];
    let buffer = [];
    let running = false;
    let timer = null;
    let speed = Number(speedRange.value);
    let wrap = (wrapSelect.value === 'true');
    let showGrid = (gridSelect.value === 'true');
    let dragging = false;
    let paintValue = 1; // when dragging, 1 to make alive, 0 to clear

    // Presets (small patterns) — coordinates relative to top-left anchor
    const PRESETS = {
      'Glider': {w:3,h:3,cells:[ [1,0],[2,1],[0,2],[1,2],[2,2] ]},
      'Lightweight spaceship': {w:5,h:4,cells:[[1,0],[4,0],[0,1],[1,1],[2,1],[3,1],[0,2],[1,2],[2,2],[3,2],[2,3]]},
      'Pulsar (small approximation)': {w:13,h:13,cells:[
        [2,0],[3,0],[4,0],[8,0],[9,0],[10,0],
        [0,2],[5,2],[7,2],[12,2],
        [0,3],[5,3],[7,3],[12,3],
        [0,4],[5,4],[7,4],[12,4],
        [2,5],[3,5],[4,5],[8,5],[9,5],[10,5],
        [2,7],[3,7],[4,7],[8,7],[9,7],[10,7],
        [0,8],[5,8],[7,8],[12,8],
        [0,9],[5,9],[7,9],[12,9],
        [0,10],[5,10],[7,10],[12,10],
        [2,12],[3,12],[4,12],[8,12],[9,12],[10,12]
      ]}
    };

    function initCanvasSize(){
      const rect = canvas.getBoundingClientRect();
      // choose a pixel size to make canvas crisp on high-DPI screens
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.max(300, Math.floor((rect.width) * dpr));
      canvas.height = Math.max(300, Math.floor((window.innerHeight - 120) * dpr));
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }

    function computeGrid(){
      const rect = canvas.getBoundingClientRect();
      cols = Math.max(10, Math.floor(rect.width / cellSize));
      rows = Math.max(10, Math.floor((canvas.height / (window.devicePixelRatio||1)) / cellSize));
      grid = new Uint8Array(cols * rows);
      buffer = new Uint8Array(cols * rows);
    }

    function index(x,y){ return y*cols + x }

    function randomize(){
      for(let i=0;i<grid.length;i++) grid[i] = Math.random() < 0.3 ? 1 : 0;
      draw();
    }

    function clearGrid(){ grid.fill(0); draw(); }

    function resizeAndKeep(){
      const oldCols = cols, oldRows = rows, old = grid.slice();
      initCanvasSize();
      const rect = canvas.getBoundingClientRect();
      cols = Math.max(10, Math.floor(rect.width / cellSize));
      rows = Math.max(10, Math.floor((canvas.height / (window.devicePixelRatio||1)) / cellSize));
      grid = new Uint8Array(cols * rows);
      buffer = new Uint8Array(cols * rows);
      // copy overlap
      const minC = Math.min(oldCols, cols);
      const minR = Math.min(oldRows, rows);
      for(let y=0;y<minR;y++){
        for(let x=0;x<minC;x++){
          grid[index(x,y)] = old[y*oldCols + x];
        }
      }
      draw();
    }

    function draw(){
      const w = canvas.clientWidth;
      const h = canvas.clientHeight / (window.devicePixelRatio||1);
      ctx.clearRect(0,0,w,h);
      // background
      ctx.fillStyle = deadColorInput.value;
      ctx.fillRect(0,0,w,h);
      // cells
      for(let y=0;y<rows;y++){
        for(let x=0;x<cols;x++){
          if(grid[index(x,y)]){
            ctx.fillStyle = aliveColorInput.value;
            ctx.fillRect(x*cellSize, y*cellSize, cellSize, cellSize);
          }
        }
      }
      // grid lines
      if(showGrid){
        ctx.strokeStyle = 'rgba(255,255,255,0.03)';
        ctx.lineWidth = 1;
        for(let x=0;x<=cols;x++){
          ctx.beginPath(); ctx.moveTo(x*cellSize,0); ctx.lineTo(x*cellSize, rows*cellSize); ctx.stroke();
        }
        for(let y=0;y<=rows;y++){
          ctx.beginPath(); ctx.moveTo(0,y*cellSize); ctx.lineTo(cols*cellSize, y*cellSize); ctx.stroke();
        }
      }
    }

    function neighbors(x,y){
      let sum = 0;
      for(let dy=-1; dy<=1; dy++){
        for(let dx=-1; dx<=1; dx++){
          if(dx===0 && dy===0) continue;
          let nx = x + dx, ny = y + dy;
          if(wrap){
            nx = (nx + cols) % cols; ny = (ny + rows) % rows;
          } else {
            if(nx < 0 || nx >= cols || ny < 0 || ny >= rows) continue;
          }
          sum += grid[index(nx,ny)];
        }
      }
      return sum;
    }

    function step(){
      // apply rules into buffer, then swap
      for(let y=0;y<rows;y++){
        for(let x=0;x<cols;x++){
          const i = index(x,y);
          const n = neighbors(x,y);
          const alive = grid[i] === 1;
          if(alive){
            buffer[i] = (n === 2 || n === 3) ? 1 : 0;
          } else {
            buffer[i] = (n === 3) ? 1 : 0;
          }
        }
      }
      const tmp = grid; grid = buffer; buffer = tmp;
      draw();
    }

    function start(){
      if(running) return;
      running = true; startBtn.textContent = '停止';
      runLoop();
    }
    function stop(){
      running = false; startBtn.textContent = '再生';
      if(timer) { clearTimeout(timer); timer = null }
    }
    function runLoop(){
      if(!running) return;
      step();
      timer = setTimeout(runLoop, speed);
    }

    // Mouse interactions
    function getCellFromEvent(e){
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / cellSize);
      const y = Math.floor((e.clientY - rect.top) / cellSize);
      return {x: Math.max(0, Math.min(cols-1,x)), y: Math.max(0, Math.min(rows-1,y)) };
    }

    canvas.addEventListener('mousedown', (e)=>{
      const c = getCellFromEvent(e);
      const i = index(c.x,c.y);
      paintValue = grid[i] ? 0 : 1;
      grid[i] = paintValue; draw();
      dragging = true;
    });
    window.addEventListener('mouseup', ()=>{ dragging = false });
    canvas.addEventListener('mousemove', (e)=>{
      if(!dragging) return;
      const c = getCellFromEvent(e);
      grid[index(c.x,c.y)] = paintValue; draw();
    });
    canvas.addEventListener('dblclick', ()=>{ running ? stop() : start() });

    // Controls binding
    startBtn.addEventListener('click', ()=>{ running ? stop() : start() });
    stepBtn.addEventListener('click', ()=>{ if(!running) step() });
    randomBtn.addEventListener('click', ()=>{ randomize() });
    clearBtn.addEventListener('click', ()=>{ clearGrid() });
    speedRange.addEventListener('input', ()=>{ speed = Number(speedRange.value) });
    cellSizeInput.addEventListener('change', ()=>{ cellSize = Number(cellSizeInput.value); resizeAndKeep() });
    wrapSelect.addEventListener('change', ()=>{ wrap = (wrapSelect.value === 'true') });
    gridSelect.addEventListener('change', ()=>{ showGrid = (gridSelect.value === 'true'); draw(); });
    aliveColorInput.addEventListener('input', draw);
    deadColorInput.addEventListener('input', draw);

    // Preset UI
    function makePresetButtons(){
      Object.keys(PRESETS).forEach(name =>{
        const btn = document.createElement('button');
        btn.textContent = name; btn.title = name;
        btn.addEventListener('click', ()=>{
          applyPreset(PRESETS[name]);
        });
        presetsDiv.appendChild(btn);
      });
    }

    function applyPreset(p){
      clearGrid();
      // center placement
      const offsetX = Math.floor((cols - p.w)/2);
      const offsetY = Math.floor((rows - p.h)/2);
      for(const [x,y] of p.cells){
        const X = x + offsetX, Y = y + offsetY;
        if(X>=0 && X<cols && Y>=0 && Y<rows) grid[index(X,Y)] = 1;
      }
      draw();
    }

    // window resize handling
    let resizeTimeout;
    window.addEventListener('resize', ()=>{
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(()=>{ resizeAndKeep(); }, 120);
    });

    // initialize
    (function(){
      initCanvasSize();
      computeGrid();
      makePresetButtons();
      randomize();
      draw();
    })();

    // keyboard shortcuts
    window.addEventListener('keydown', (e)=>{
      if(e.key === ' ') { e.preventDefault(); running ? stop() : start(); }
      if(e.key === 'n') { if(!running) step(); }
      if(e.key === 'c') { clearGrid(); }
      if(e.key === 'r') { randomize(); }
    });

  </script>
</body>
</html>
